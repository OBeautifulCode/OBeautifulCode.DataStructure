// --------------------------------------------------------------------------------------------------------------------
// <auto-generated>
//   Generated using OBeautifulCode.CodeGen.ModelObject (1.0.209.0)
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.CoreOperation.Test
{
    using global::System;
    using global::System.CodeDom.Compiler;
    using global::System.Collections.Concurrent;
    using global::System.Collections.Generic;
    using global::System.Collections.ObjectModel;
    using global::System.Diagnostics.CodeAnalysis;

    using global::FakeItEasy;

    using global::OBeautifulCode.AutoFakeItEasy;
    using global::OBeautifulCode.CoreOperation;
    using global::OBeautifulCode.Math.Recipes;
    using global::OBeautifulCode.Type;

    /// <summary>
    /// The default (code generated) Dummy Factory.
    /// Derive from this class to add any overriding or custom registrations.
    /// </summary>
    [ExcludeFromCodeCoverage]
    [GeneratedCode("OBeautifulCode.CodeGen.ModelObject", "1.0.209.0")]
#if !OBeautifulCodeCoreOperationSolution
    internal
#else
    public
#endif
    abstract class DefaultCoreOperationDummyFactory : IDummyFactory
    {
        public DefaultCoreOperationDummyFactory()
        {
            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new AndAlsoOp
                             {
                                 Statements = A.Dummy<IReadOnlyCollection<IReturningOperation<bool>>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new CompareOp
                             {
                                 Left     = A.Dummy<IReturningOperation<decimal>>(),
                                 Operator = A.Dummy<IReturningOperation<CompareOperator>>(),
                                 Right    = A.Dummy<IReturningOperation<decimal>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new DivideOp
                             {
                                 Numerator   = A.Dummy<IReturningOperation<decimal>>(),
                                 Denominator = A.Dummy<IReturningOperation<decimal>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new GetConstValueOp<Version>
                             {
                                 Value = A.Dummy<Version>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new GetNumberOfSignificantDigitsOp
                             {
                                 Statement = A.Dummy<IReturningOperation<decimal>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new IfThenElseOp<Version>
                             {
                                 Condition     = A.Dummy<IReturningOperation<bool>>(),
                                 Statement     = A.Dummy<IReturningOperation<Version>>(),
                                 ElseStatement = A.Dummy<IReturningOperation<Version>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new IsEqualToOp<Version>
                             {
                                 Statement1 = A.Dummy<IReturningOperation<Version>>(),
                                 Statement2 = A.Dummy<IReturningOperation<Version>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () =>
                {
                    var availableTypes = new[]
                    {
                        typeof(NullMultiStatementOp<Version, Version>)
                    };

                    var randomIndex = ThreadSafeRandom.Next(0, availableTypes.Length);

                    var randomType = availableTypes[randomIndex];

                    var result = (MultiStatementOpBase<Version, Version>)AD.ummy(randomType);

                    return result;
                });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new NotOp
                             {
                                 Statement = A.Dummy<IReturningOperation<bool>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new NullMultiStatementOp<Version, Version>
                             {
                                 Statements = A.Dummy<IReadOnlyCollection<IReturningOperation<Version>>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new NullSingleStatementOp<Version, Version>
                             {
                                 Statement = A.Dummy<IReturningOperation<Version>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new NullTwoStatementOp<Version, Version>
                             {
                                 Statement1 = A.Dummy<IReturningOperation<Version>>(),
                                 Statement2 = A.Dummy<IReturningOperation<Version>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new OrElseOp
                             {
                                 Statements = A.Dummy<IReadOnlyCollection<IReturningOperation<bool>>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () =>
                {
                    var availableTypes = new[]
                    {
                        typeof(NullSingleStatementOp<Version, Version>)
                    };

                    var randomIndex = ThreadSafeRandom.Next(0, availableTypes.Length);

                    var randomType = availableTypes[randomIndex];

                    var result = (SingleStatementOpBase<Version, Version>)AD.ummy(randomType);

                    return result;
                });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new SumOp
                             {
                                 Statements = A.Dummy<IReadOnlyCollection<IReturningOperation<decimal>>>(),
                             });

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new ThrowOpExecutionAbortedExceptionOp(
                                 A.Dummy<string>()));

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new ThrowOpExecutionAbortedExceptionOp<Version>(
                                 A.Dummy<string>()));

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new ThrowOpExecutionDeemedNotApplicableExceptionOp(
                                 A.Dummy<string>()));

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new ThrowOpExecutionDeemedNotApplicableExceptionOp<Version>(
                                 A.Dummy<string>()));

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new ThrowOpExecutionFailedExceptionOp(
                                 A.Dummy<string>()));

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () => new ThrowOpExecutionFailedExceptionOp<Version>(
                                 A.Dummy<string>()));

            AutoFixtureBackedDummyFactory.AddDummyCreator(
                () =>
                {
                    var availableTypes = new[]
                    {
                        typeof(NullTwoStatementOp<Version, Version>)
                    };

                    var randomIndex = ThreadSafeRandom.Next(0, availableTypes.Length);

                    var randomType = availableTypes[randomIndex];

                    var result = (TwoStatementOpBase<Version, Version>)AD.ummy(randomType);

                    return result;
                });
        }

        /// <inheritdoc />
        public Priority Priority => new FakeItEasy.Priority(1);

        /// <inheritdoc />
        public bool CanCreate(Type type)
        {
            return false;
        }

        /// <inheritdoc />
        public object Create(Type type)
        {
            return null;
        }
    }
}